# 12 \_함수

## 12.3 함수 리터럴

> 자바스크립트에서 함수는 객체 타입의 값이다.
> 숫자 값을 숫자 리터럴로 생성하고 객체를 객체 리터럴로 생성하는 것처럼
> 함수도 함수 리터럴로 생성할 수 있다.
> 함수 리터럴은 function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체로 구성된다.

<br>

```
// 변수에 함수 리터럴을 할당
let f = function add(x, y) {
	return x + y;
};
```

- 표현식: 값으로 평가될 수 있다.

<br>

## 12.4.1 함수선언문

```
function add(x, y) {
	return x + y;
}
```

<br>

함수 리터럴은 함수 이름을 생략할 수 있지만 함수 선언문은 함수 이름을 생략할 수 없다.

```
function (x, y) {
	return x + y;
}
// SyntaxError
```

<br>

함수 선언문은 표현식이 아닌 문이다.
함수 선언문이 만약 표현식인 문이라면 undefined이 아닌 표현식이 평가되어 생성된 함수가 출력되어야 한다.

```
function add(x, y) {
	return x + y;
}

=> undefined
```

<br>

표현식이 아닌 문은 변수에 할당할 수 없다.
함수선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다.
다음 예제는 함수 선언문이 변수에 할당되는 것처럼 보인다.

```
const add = function add(x, y) {
	return x + y;
};

console.log(add(2,5));
```

<br>

자바스크립트 엔진은 코드의 문맥에 따라 동일함 함수 리터럴을 표현식이 아닌 문인 함수 선언문으로 해석하는 경우와 표현식인 문인 함수 리터럴 표현식으로 해석하는 경우가 있다.

함수 선언문은 함수 이름을 생략할 수 없다. 이 부분만 제외하면 함수 리터럴과 형태가 동일하다.
이는 함수 이름이 있는 기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 해석될 가능성이 있다는 것이다.

예를 들어, {}는 블록문일 수도 있고 객체 리터럴일 수도 있다.

{}가 단독으로 쓰이면 블록문, 피연산자로 쓰이면 객체 리터럴이다.

기명 함수 리터럴도 중의적인 코드로 코드의 문맥에 따라 해석이 달라지게 된다.

```
// 기명 함수를 단독으로 사용하면 함수 선언문
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() { console.log('foo'); }

foo(); // 'foo'

// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아닌 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
(function bar() { console.log('bar'); });
bar(); / ReferenceError: bar is not defined
```

<br>

위 예제에서 단독으로 사용된 함수 리터럴(foo)는 함수 선언문으로 해석된다. 그룹 연산자 () 내에 있는 함수 리터럴(bar)은 함수 리터럴로 해석된다. 그룹 연산자의 피연산는 값으로 평가될 수 있는 표현식이어야 한다. 표현식이 아닌 문인 함수 선언문은 피연산자로 사용할 수 없다.

자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.

아래는 함수 선언문을 자바스크립트 엔진이 식별자로 호출해주는 코드이다.

```
var add = function add(x, y) {
	return x + y;
};

console.log(add(2, 5)); // 7
```

<br>

함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가르키는 식별자로 호출한다.

즉, 함수 선언문으로 생성한 함수를 호출하는 것은 함수 이름 add가 아닌 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다.

결론적으로 자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환해 함수 객체를 생성한다고 볼 수 있지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하는 것은 아니다.

<br>

## 12.4.2 함수 표현식

자바스크립트의 함수는 객체 타입의 값이다. 자바스크립트의 함수는 값처럼 변수에 할당할 수 있고 프러퍼티 값이 될 수도 있고 배열의 요소가 될 수도 있다.

이렇게 값의 성질을 갖는 객체를 일급 객체라고 한다. 함수가 일급 객체라는 의미는 함수를 값처럼 자유롭게 사용할 수 있다는 의미이다.

함수는 일급 객체이기 때문에 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식이라 한다.

함수 선언문으로 정의한 add 함수를 함수 표현식으로 바꿔 정의해보자.

```
const add = function (x, y) {
	return x + y;
}

console.log(add(2, 5)); // 7
```

<br>

함수 리터럴의 함수 이름은 생략 가능하고 이를 익명 함수라 한다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.

함수 호출 시 함수 이름이 아닌 함수를 가르키는 식별자를 사용해야 한다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없다.

```
// 기명 함수 표현식
const add = function foo (x, y) {
	return x + y;
}

// 함수 객체를 가르키는 식별자로 호출
console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.
console.log(foo(2, 5)); // ReferenceError: fo is not defined
```

<br>

자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다.

하지만 함수 선언문과 함수 표현식이 정확히 동일하게 동작하지는 않는다.

함수 선언문은 "표현식이 아닌 문"이고 함수 표현식은 "표현식인 문"이다.
